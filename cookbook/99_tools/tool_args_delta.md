# Streaming Tool Call Arguments (tool_args.delta)

This document describes the `tool_args.delta` feature for streaming tool call arguments in real-time as they arrive from the model.

## Overview

When using streaming responses with agents that have tools, you can now receive incremental updates of tool call arguments as they are being generated by the model. This enables:

- Real-time progress tracking of tool call argument building
- UI updates as tool parameters are streamed in
- Early validation of tool arguments before they're complete

## Event Types

### ToolCallArgsDeltaEvent

The `ToolCallArgsDeltaEvent` is emitted for each incremental chunk of tool call arguments.

```python
from agno.run.agent import ToolCallArgsDeltaEvent

@dataclass
class ToolCallArgsDeltaEvent(BaseAgentRunEvent):
    """Event for streaming tool call arguments as they arrive (delta updates)."""
    event: str = RunEvent.tool_call_args_delta.value
    tool_call_id: Optional[str] = None
    tool_call_name: Optional[str] = None
    delta: Optional[str] = None  # JSON fragment
```

### ToolCallArgsCompletedEvent

The `ToolCallArgsCompletedEvent` is emitted when tool call arguments have been completely streamed and parsed.

```python
from agno.run.agent import ToolCallArgsCompletedEvent

@dataclass
class ToolCallArgsCompletedEvent(BaseAgentRunEvent):
    """Event emitted when tool call arguments have been completely streamed."""
    event: str = RunEvent.tool_call_args_completed.value
    tool_call_id: Optional[str] = None
    tool_call_name: Optional[str] = None
    tool_args: Optional[Dict[str, Any]] = None  # Complete tool arguments
```

### Related Events

| Event | Description |
|-------|-------------|
| `ToolCallStartedEvent` | Tool call begins, `tool_args=None` |
| `ToolCallArgsDeltaEvent` | Each chunk of tool call arguments |
| `ToolCallArgsCompletedEvent` | Arguments complete with full `tool_args` |
| `ToolCallCompletedEvent` | Tool execution complete with `result` |

## Event Flow (Streaming)

### Normal Tool Calls (without confirmation)

When a model generates a tool call with streaming arguments:

```
User Input: "Calculate 123 * 456"
    |
    v
ToolCallStartedEvent: tool_name="multiply", tool_args=None  (tool call begins)
    |
    v
ToolCallArgsDeltaEvent: delta=""  (first chunk, empty args)
    |
    v
ToolCallArgsDeltaEvent: delta="{"
    |
    v
ToolCallArgsDeltaEvent: delta='"a'
    |
    v
ToolCallArgsDeltaEvent: delta='"a": 123, "b'
    |
    v
ToolCallArgsDeltaEvent: delta='"a": 123, "b": 456}'
    |
    v
ToolCallArgsCompletedEvent: tool_args={'a': 123, 'b': 456}  (complete arguments)
    |
    v
ToolCallCompletedEvent: result=56088  (tool execution complete)
```

### Human-in-the-Loop (HITL) Tool Calls

When a tool requires confirmation (`requires_confirmation=True`), the flow is:

```
User Input: "Send an email..."
    |
    v
ToolCallArgsDeltaEvent: delta=""  (first chunk with id/name)
    |
    v
ToolCallArgsCompletedEvent: tool_args={"to": "...", "subject": "..."}  (args complete)
    |
    v
RunPausedEvent: tool with requires_confirmation=True  (wait for user)
    |
    v
[User confirms the tool call]
    |
    v
ToolCallCompletedEvent: result="Email sent successfully"
```

**Note:** For HITL tool calls, `ToolCallArgsCompletedEvent` is emitted along with `RunPausedEvent`, providing the complete `tool_args` before pausing for user confirmation.

## API Reference

### ToolCallArgsDeltaEvent

```python
@dataclass
class ToolCallArgsDeltaEvent(BaseAgentRunEvent):
    """Event emitted for each incremental chunk of tool call arguments."""

    event: str = RunEvent.tool_call_args_delta.value
    tool_call_id: Optional[str] = None
    tool_call_name: Optional[str] = None
    delta: Optional[str] = None  # JSON fragment
```

### ToolCallArgsCompletedEvent

```python
@dataclass
class ToolCallArgsCompletedEvent(BaseAgentRunEvent):
    """Event emitted when tool call arguments have been completely streamed.
    
    Note: Not emitted for HITL tool calls (requires_confirmation=True).
    """

    event: str = RunEvent.tool_call_args_completed.value
    tool_call_id: Optional[str] = None
    tool_call_name: Optional[str] = None
    tool_args: Optional[Dict[str, Any]] = None  # Complete tool arguments
```
User Input: "Calculate 123 * 456"
    |
    v
ToolCallStartedEvent: tool_name="multiply", tool_args=None  (tool call begins)
    |
    v
ToolCallArgsDeltaEvent: delta=""  (first chunk, empty args)
    |
    v
ToolCallArgsDeltaEvent: delta="{"
    |
    v
ToolCallArgsDeltaEvent: delta='"a'
    |
    v
ToolCallArgsDeltaEvent: delta='"a": 123, "b'
    |
    v
ToolCallArgsDeltaEvent: delta='"a": 123, "b": 456}'
    |
    v
ToolCallArgsCompletedEvent: tool_args={'a': 123, 'b': 456}  (complete arguments)
    |
    v
ToolCallCompletedEvent: result=56088  (tool execution complete)
```

**Event Order:**
1. `ToolCallStartedEvent` - Tool call begins, `tool_args=None`
2. `ToolCallArgsDeltaEvent` (multiple) - Incremental JSON fragments
3. `ToolCallArgsCompletedEvent` - Complete `tool_args` dictionary
4. `ToolCallCompletedEvent` - Full execution with `result`

## Delta Format

The `delta` field contains incremental JSON fragments:

- First chunk may include `id` and `name` (if provided by the model)
- Subsequent chunks contain argument fragments
- Fragments are concatenated to build the complete JSON object

### Example Delta Sequence

```python
# Initial chunk (if model provides id/name separately)
delta = ""  # Empty arguments but id and name are set in the event

# Arguments start streaming
delta = "{"
delta = '{"a'
delta = '"a": '
delta = '"a": 1'
delta = '"a": 123, '
delta = '"a": 123, "b'
delta = '"a": 123, "b": '
delta = '"a": 123, "b": 4'
delta = '"a": 123, "b": 456'
delta = '"a": 123, "b": 456}'
```

## Complete Example with Real Model

```python
import os
from agno.agent import Agent
from agno.models.deepseek import DeepSeek
from agno.run.agent import (
    ToolCallArgsDeltaEvent,
    ToolCallArgsCompletedEvent,
    ToolCallStartedEvent,
    ToolCallCompletedEvent,
)

# Set up DeepSeek (or any OpenAI-compatible model)
os.environ["DEEPSEEK_API_KEY"] = "your-api-key"

agent = Agent(
    model=DeepSeek(id="deepseek-chat"),
    tools=[my_multiply_tool],
    stream_events=True,
)

print("Request: Calculate 25 * 40")
print("-" * 50)

for chunk in agent.run("Calculate 25 * 40", stream=True):
    if isinstance(chunk, ToolCallStartedEvent):
        print(f"\n[ToolStarted] {chunk.tool.tool_name}")
        print(f"  tool_call_id: {chunk.tool.tool_call_id}")
        print(f"  tool_args: {chunk.tool.tool_args}")  # None

    elif isinstance(chunk, ToolCallArgsDeltaEvent):
        print(chunk.delta, end="", flush=True)  # Prints JSON fragments

    elif isinstance(chunk, ToolCallArgsCompletedEvent):
        print(f"\n[ArgsCompleted]")
        print(f"  tool_args: {chunk.tool_args}")  # {'x': 25, 'y': 40}

    elif isinstance(chunk, ToolCallCompletedEvent):
        print(f"\n[ToolCompleted] Result: {chunk.tool.result}")

# Output:
# Request: Calculate 25 * 40
# --------------------------------------------------
#
# [ToolStarted] multiply
#   tool_call_id: call_xxx
#   tool_args: None
# {"x": 25, "y": 40}
# [ArgsCompleted]
#   tool_args: {'x': 25, 'y': 40}
# [ToolCompleted] Result: 1000
```

### Example: Collecting Arguments at Completion

```python
from agno.run.agent import ToolCallArgsCompletedEvent, ToolCallCompletedEvent

for chunk in agent.run("...", stream=True):
    if isinstance(chunk, ToolCallArgsCompletedEvent):
        # Get complete arguments as soon as they're available
        complete_args = chunk.tool_args
        print(f"Arguments ready: {complete_args}")

    elif isinstance(chunk, ToolCallCompletedEvent):
        # Get the result
        result = chunk.tool.result
        print(f"Result: {result}")
```

## Important: Event Order and Arguments

When using streaming with `tool_args.delta`:

1. **First Event**: `ToolCallStartedEvent` with `tool_args=None`
   - The first `ToolCallStartedEvent` indicates the tool call has started
   - At this point, arguments may not be complete yet, so `tool_args` is `None`

2. **Streaming Events**: Multiple `ToolCallArgsDeltaEvent`
   - Each delta event contains a fragment of the JSON arguments
   - Concatenate deltas to build the complete arguments

3. **Final Event**: `ToolCallCompletedEvent` with complete `tool_args`
   - When the tool call completes, you get the full arguments and result
   - Use this for complete tool execution information

### Example: Collecting Complete Arguments

```python
import json
from agno.run.agent import ToolCallArgsDeltaEvent, ToolCallCompletedEvent

complete_args = ""
complete_result = None

for chunk in agent.run("...", stream=True):
    if isinstance(chunk, ToolCallArgsDeltaEvent):
        # Accumulate argument fragments
        complete_args += chunk.delta or ""

    elif isinstance(chunk, ToolCallCompletedEvent):
        # Get complete arguments from the completed event
        complete_result = chunk.tool.result
        complete_tool_args = chunk.tool.tool_args
        print(f"Tool: {chunk.tool.tool_name}")
        print(f"Result: {complete_result}")
        print(f"Args: {complete_tool_args}")

## Supported Models

### OpenAI-Compatible Models

- OpenAI (`gpt-4`, `gpt-4o`, etc.)
- DeepSeek (`deepseek-chat`, `deepseek-reasoner`)
- Any model using OpenAI's streaming protocol with `tool_calls`

### Anthropic Claude

- Claude 3.5 Sonnet
- Claude 3 Opus
- Claude 4 models (when available)

## Configuration

### Agent Configuration

| Parameter | Type | Description |
|-----------|------|-------------|
| `stream_events` | `bool` | Enable event streaming (required for delta events) |
| `show_tool_calls` | `bool` | Print tool calls to console |

### Example

```python
agent = Agent(
    model=OpenAIChat(id="gpt-4o"),
    tools=[calculator, search_tool],
    stream_events=True,  # Required for ToolCallArgsDeltaEvent
    show_tool_calls=True,  # Optional: prints tool calls
)
```

## API Reference

### ToolCallArgsDeltaEvent

```python
@dataclass
class ToolCallArgsDeltaEvent(BaseAgentRunEvent):
    """Event emitted when tool call arguments are streamed incrementally."""

    # From BaseAgentRunEvent
    event: str = RunEvent.tool_call_args_delta.value
    run_id: Optional[str] = None
    session_id: Optional[str] = None
    agent_id: Optional[str] = None
    agent_name: Optional[str] = None

    # Tool call information
    tool_call_id: Optional[str] = None  # Unique identifier for this tool call
    tool_call_name: Optional[str] = None  # Name of the tool being called
    delta: Optional[str] = None  # Incremental JSON fragment
```

### Helper Functions

```python
from agno.utils.events import create_tool_call_args_delta_event

# Create a ToolCallArgsDeltaEvent
event = create_tool_call_args_delta_event(
    from_run_response=run_response,
    tool_call_id="call_abc123",
    tool_call_name="my_tool",
    delta='{"arg1": "value',
)
```

## Best Practices

1. **Accumulate deltas**: Store the `delta` fragments and concatenate them to build the complete JSON object.

2. **Handle JSON parsing**: Use `json.loads()` only when the arguments are complete (you can detect completion when the JSON is valid).

3. **Early validation**: For simple validation, you can check partial JSON as it arrives.

4. **Error handling**: Wrap delta processing in try-except blocks since partial JSON may not be valid.

```python
import json
import re
from agno.run.agent import ToolCallArgsDeltaEvent

def validate_partial_json(partial: str) -> bool:
    """Check if partial JSON is syntactically valid so far."""
    # Remove trailing commas which are invalid in JSON
    if partial.rstrip().endswith(','):
        return False
    # Check for balanced braces
    open_braces = partial.count('{') - partial.count('}')
    return open_braces >= 0

complete_args = ""
for chunk in agent.run("...", stream=True):
    if isinstance(chunk, ToolCallArgsDeltaEvent):
        delta = chunk.delta or ""
        complete_args += delta

        # Check if we have a complete, valid JSON object
        if complete_args.startswith('{') and complete_args.endswith('}'):
            try:
                args = json.loads(complete_args)
                print(f"Complete arguments: {args}")
            except json.JSONDecodeError:
                pass  # Not complete yet
```

## Troubleshooting

### No ToolCallArgsDeltaEvent received

1. Ensure `stream_events=True` is set on the Agent
2. Check that the model actually generates tool calls
3. Verify the model supports streaming tool call arguments

### Empty tool_call_id or tool_call_name

Some models (like some OpenAI-compatible providers) may not include `id` and `name` in every chunk. The first chunk typically contains these values, and subsequent chunks only contain arguments. The Agent tracks and preserves these values across chunks.

## Migration Guide

### From Non-Streaming to Streaming

If you previously used non-streaming tool calls:

```python
# Before (non-streaming)
response = agent.run("Calculate 123 * 456")
print(response.tools[0].tool_args)  # Complete arguments only
```

```python
# After (streaming with deltas)
for chunk in agent.run("Calculate 123 * 456", stream=True):
    if isinstance(chunk, ToolCallArgsDeltaEvent):
        print(f"Delta: {chunk.delta}")  # Incremental updates
```

## Limitations

- Not all models support streaming tool call arguments
- The `delta` field contains raw JSON fragments that may not be valid JSON until complete
- Some models may not include `tool_call_id` in every chunk (the Agent tracks this)
- Performance impact is minimal but should be considered for high-throughput scenarios
